<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procesador KML con Elevación</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            min-height: 100vh;
        }
        .drag-area-highlight {
            background-color: #f0f9ff;
            border-color: #3b82f6;
        }
        .preview-table {
            max-height: 300px;
            overflow-y: auto;
        }
        .preview-table table {
            min-width: 100%;
        }
        .preview-table th {
            position: sticky;
            top: 0;
            background-color: #3b82f6;
            color: white;
            z-index: 10;
        }
        .tab-button {
            transition: all 0.3s ease;
        }
        .tab-button.active {
            background-color: #3b82f6;
            color: white;
        }
        .api-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .api-status.online {
            background-color: #10B981;
        }
        .api-status.offline {
            background-color: #EF4444;
        }
        .api-status.checking {
            background-color: #F59E0B;
        }
    </style>
</head>
<body class="flex items-center justify-center p-4 py-8">
    <div class="bg-white rounded-xl shadow-xl p-6 md:p-8 w-full max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Procesador KML con Elevación</h1>
            <p class="text-gray-600">Sube tu archivo KML para calcular elevaciones, distancias y exportar los resultados.</p>
        </header>

        <!-- Selector de método de obtención de elevación -->
        <div class="mb-6 bg-gray-50 p-4 rounded-lg">
            <h3 class="font-semibold text-gray-800 mb-3">Método de obtención de elevación:</h3>
            <div class="flex flex-wrap gap-2">
                <button id="apiOpenTopo" class="tab-button active px-4 py-2 rounded-lg border border-gray-300">
                    <span class="api-status checking" id="openTopoStatus"></span>
                    OpenTopoData (online)
                </button>
                <button id="apiGoogle" class="tab-button px-4 py-2 rounded-lg border border-gray-300">
                    <span class="api-status checking" id="googleStatus"></span>
                    Google Maps (online)
                </button>
                <button id="manualElevation" class="tab-button px-4 py-2 rounded-lg border border-gray-300">
                    Manual (sin conexión)
                </button>
            </div>
            <div id="apiInfo" class="text-sm text-gray-600 mt-3">
                <p id="currentApiInfo">Verificando disponibilidad de servicios de elevación...</p>
            </div>
        </div>

        <!-- Área de carga de archivos -->
        <div id="dropZone" class="mb-6 border-2 border-dashed border-gray-300 rounded-xl p-6 transition-all duration-300 cursor-pointer">
            <label for="fileInput" class="cursor-pointer flex flex-col items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-16 h-16 text-gray-400 mb-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 13.5l3 3m0 0l3-3m-3 3v-6m1.06-4.19l-2.12-2.12a1.5 1.5 0 00-1.06-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
                </svg>
                <span class="text-gray-600 font-medium text-center mb-2">Arrastra y suelta tu archivo KML aquí</span>
                <span class="text-gray-500 text-sm">o haz clic para seleccionar</span>
            </label>
            <input type="file" id="fileInput" accept=".kml" class="hidden">
        </div>

        <!-- Información del archivo -->
        <div id="fileInfo" class="hidden mb-6 bg-blue-50 p-4 rounded-lg border border-blue-200">
            <div class="flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-blue-500 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                </svg>
                <span id="fileName" class="text-blue-700 font-medium"></span>
                <span id="fileSize" class="text-blue-600 ml-2"></span>
            </div>
            <div id="pointsCount" class="text-blue-600 text-sm mt-1"></div>
        </div>

        <!-- Indicador de estado y progreso -->
        <div id="statusMessage" class="mb-4 text-sm"></div>
        <div id="progressBarContainer" class="hidden w-full bg-gray-200 rounded-full h-2.5 mb-6">
            <div id="progressBar" class="bg-blue-500 h-2.5 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
        </div>

        <!-- Vista previa de datos -->
        <div id="previewContainer" class="hidden mb-6">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-semibold text-gray-800">Vista Previa de Datos</h3>
                <span class="text-sm text-gray-500" id="previewInfo"></span>
            </div>
            <div class="preview-table border border-gray-200 rounded-lg overflow-hidden">
                <table class="w-full text-sm text-left text-gray-700">
                    <thead class="text-xs uppercase">
                        <tr>
                            <th class="px-4 py-2">Punto</th>
                            <th class="px-4 py-2">Latitud</th>
                            <th class="px-4 py-2">Longitud</th>
                            <th class="px-4 py-2">Elevación (m)</th>
                            <th class="px-4 py-2">Dist. Parcial (m)</th>
                            <th class="px-4 py-2">Dist. Acumulada (m)</th>
                        </tr>
                    </thead>
                    <tbody id="previewTableBody" class="bg-white divide-y divide-gray-200">
                        <!-- Los datos se insertarán aquí dinámicamente -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Estadísticas de procesamiento -->
        <div id="statsContainer" class="hidden grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <div class="bg-gray-50 p-4 rounded-lg text-center">
                <div class="text-2xl font-bold text-gray-800" id="totalPoints">0</div>
                <div class="text-gray-600 text-sm">Puntos totales</div>
            </div>
            <div class="bg-gray-50 p-4 rounded-lg text-center">
                <div class="text-2xl font-bold text-gray-800" id="totalDistance">0</div>
                <div class="text-gray-600 text-sm">Distancia total (m)</div>
            </div>
            <div class="bg-gray-50 p-4 rounded-lg text-center">
                <div class="text-2xl font-bold text-gray-800" id="maxElevation">0</div>
                <div class="text-gray-600 text-sm">Elevación máxima (m)</div>
            </div>
            <div class="bg-gray-50 p-4 rounded-lg text-center">
                <div class="text-2xl font-bold text-gray-800" id="minElevation">0</div>
                <div class="text-gray-600 text-sm">Elevación mínima (m)</div>
            </div>
        </div>

        <!-- Botones de descarga -->
        <div class="flex flex-col md:flex-row gap-4">
            <button id="downloadKmlBtn" class="flex-1 flex items-center justify-center gap-2 bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                Descargar KML
            </button>
            <button id="downloadCsvBtn" class="flex-1 flex items-center justify-center gap-2 bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                Descargar CSV
            </button>
        </div>

        <!-- Información de la API -->
        <div class="mt-8 text-center text-xs text-gray-500">
            <p id="apiCredit">Utilizando el servicio <a href="https://www.opentopodata.org/" class="text-blue-500 hover:underline" target="_blank">OpenTopoData</a> para obtener datos de elevación.</p>
            <p class="mt-1">Límite: 100 ubicaciones por solicitud. Procesando en lotes.</p>
        </div>
    </div>

    <script>
        // Variables globales
        let processedKml = '';
        let processedCsv = '';
        let enrichedData = [];
        let currentApi = 'opentopodata'; // Valor por defecto

        // Referencias a elementos DOM
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const statusMessage = document.getElementById('statusMessage');
        const downloadKmlBtn = document.getElementById('downloadKmlBtn');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const progressBar = document.getElementById('progressBar');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const pointsCount = document.getElementById('pointsCount');
        const statsContainer = document.getElementById('statsContainer');
        const totalPointsEl = document.getElementById('totalPoints');
        const totalDistanceEl = document.getElementById('totalDistance');
        const maxElevationEl = document.getElementById('maxElevation');
        const minElevationEl = document.getElementById('minElevation');
        const previewContainer = document.getElementById('previewContainer');
        const previewTableBody = document.getElementById('previewTableBody');
        const previewInfo = document.getElementById('previewInfo');
        const apiOpenTopoBtn = document.getElementById('apiOpenTopo');
        const apiGoogleBtn = document.getElementById('apiGoogle');
        const manualElevationBtn = document.getElementById('manualElevation');
        const openTopoStatus = document.getElementById('openTopoStatus');
        const googleStatus = document.getElementById('googleStatus');
        const currentApiInfo = document.getElementById('currentApiInfo');
        const apiCredit = document.getElementById('apiCredit');

        // Event Listeners
        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            // Configurar eventos de arrastrar y soltar
            setupDragAndDrop();
            
            // Event listener para selección de archivo
            fileInput.addEventListener('change', handleFileSelect);
            
            // Event listeners para botones de descarga
            downloadKmlBtn.addEventListener('click', () => {
                downloadFile(processedKml, 'ruta_con_elevacion.kml', 'application/vnd.google-earth.kml+xml');
            });
            
            downloadCsvBtn.addEventListener('click', () => {
                downloadFile(processedCsv, 'ruta_con_elevacion.csv', 'text/csv;charset=utf-8;');
            });
            
            // Event listeners para selección de API
            apiOpenTopoBtn.addEventListener('click', () => switchApi('opentopodata'));
            apiGoogleBtn.addEventListener('click', () => switchApi('google'));
            manualElevationBtn.addEventListener('click', () => switchApi('manual'));
            
            // Verificar estado de las APIs
            checkApiStatus();
        }

        function switchApi(api) {
            currentApi = api;
            
            // Actualizar UI
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            if (api === 'opentopodata') {
                apiOpenTopoBtn.classList.add('active');
                currentApiInfo.textContent = 'Utilizando OpenTopoData para obtener datos de elevación.';
                apiCredit.innerHTML = 'Utilizando el servicio <a href="https://www.opentopodata.org/" class="text-blue-500 hover:underline" target="_blank">OpenTopoData</a> para obtener datos de elevación.';
            } else if (api === 'google') {
                apiGoogleBtn.classList.add('active');
                currentApiInfo.textContent = 'Utilizando Google Maps Elevation API. Requiere clave API.';
                apiCredit.innerHTML = 'Utilizando el servicio <a href="https://developers.google.com/maps/documentation/elevation/start" class="text-blue-500 hover:underline" target="_blank">Google Maps Elevation API</a> para obtener datos de elevación.';
            } else {
                manualElevationBtn.classList.add('active');
                currentApiInfo.textContent = 'Modo manual: usando elevaciones existentes en el archivo KML o valor por defecto (0).';
                apiCredit.textContent = 'Modo manual: usando elevaciones existentes en el archivo KML o valor por defecto.';
            }
        }

        async function checkApiStatus() {
            // Verificar OpenTopoData
            openTopoStatus.className = 'api-status checking';
            try {
                const response = await fetchWithTimeout('https://api.opentopodata.org/v1/test', { timeout: 5000 });
                openTopoStatus.className = response.ok ? 'api-status online' : 'api-status offline';
            } catch (e) {
                openTopoStatus.className = 'api-status offline';
            }
            
            // Verificar Google (siempre marcado como disponible, pero requiere clave)
            googleStatus.className = 'api-status online';
        }

        function setupDragAndDrop() {
            // Prevenir comportamientos por defecto
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            // Resaltar área de drop
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });
            
            // Manejar archivo soltado
            dropZone.addEventListener('drop', handleDrop, false);
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight() {
                dropZone.classList.add('drag-area-highlight');
            }
            
            function unhighlight() {
                dropZone.classList.remove('drag-area-highlight');
            }
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length) {
                    fileInput.files = files;
                    handleFileSelect({ target: fileInput });
                }
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                updateStatus('Por favor, selecciona un archivo.', 'error');
                return;
            }
            
            // Validar extensión del archivo
            if (!file.name.toLowerCase().endsWith('.kml')) {
                updateStatus('Por favor, selecciona un archivo con extensión .kml', 'error');
                return;
            }
            
            // Mostrar información del archivo
            showFileInfo(file);
            
            // Reiniciar estado de la UI
            resetUI();
            updateStatus('Procesando archivo...', 'info');
            
            try {
                const kmlText = await readFileAsText(file);
                await processKmlFile(kmlText);
            } catch (error) {
                console.error("Error:", error);
                updateStatus(`Error: ${error.message}`, 'error');
                progressBarContainer.classList.add('hidden');
            }
        }

        function showFileInfo(file) {
            const sizeInKB = (file.size / 1024).toFixed(2);
            fileName.textContent = file.name;
            fileSize.textContent = `(${sizeInKB} KB)`;
            fileInfo.classList.remove('hidden');
        }

        function resetUI() {
            downloadKmlBtn.disabled = true;
            downloadCsvBtn.disabled = true;
            progressBarContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            statsContainer.classList.add('hidden');
            previewContainer.classList.add('hidden');
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = () => reject(new Error('No se pudo leer el archivo.'));
                reader.readAsText(file);
            });
        }

        async function processKmlFile(kmlText) {
            try {
                // Parsear KML
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlText, "text/xml");
                
                // Verificar si es un documento KML válido
                if (kmlDoc.getElementsByTagName("parsererror").length > 0) {
                    throw new Error('El archivo no es un KML válido.');
                }
                
                // Obtener coordenadas
                const lineString = kmlDoc.querySelector('LineString');
                if (!lineString) {
                    throw new Error('El archivo KML no contiene un elemento LineString.');
                }
                
                const coordinatesText = lineString.querySelector('coordinates').textContent.trim();
                const coordinates = parseCoordinates(coordinatesText);
                
                // Mostrar conteo de puntos
                pointsCount.textContent = `${coordinates.length} puntos detectados`;
                
                // Calcular elevaciones y distancias según el método seleccionado
                enrichedData = await calculateElevationsAndDistances(coordinates);
                
                // Generar archivos de salida
                processedKml = createKml(kmlDoc, enrichedData);
                processedCsv = createCsv(enrichedData);
                
                // Actualizar estadísticas
                updateStats(enrichedData);
                
                // Mostrar vista previa
                showDataPreview(enrichedData);
                
                // Habilitar descargas
                downloadKmlBtn.disabled = false;
                downloadCsvBtn.disabled = false;
                
                updateStatus('¡Procesamiento completado! Revisa la vista previa y descarga los archivos.', 'success');
                progressBar.style.width = '100%';
                
            } catch (error) {
                console.error("Error al procesar el archivo:", error);
                updateStatus(`Error: ${error.message}`, 'error');
                progressBarContainer.classList.add('hidden');
            }
        }

        function parseCoordinates(coordinatesText) {
            return coordinatesText.split(/\s+/)
                .filter(coord => coord.trim() !== '')
                .map(coordStr => {
                    const parts = coordStr.split(',');
                    // Algunos archivos KML pueden incluir elevación en la tercera coordenada
                    return {
                        lon: parseFloat(parts[0]),
                        lat: parseFloat(parts[1]),
                        elev: parts.length > 2 ? parseFloat(parts[2]) : null
                    };
                });
        }

        async function calculateElevationsAndDistances(coordinates) {
            const enrichedData = [];
            let cumulativeDistance = 0;
            
            // Diferentes métodos según la API seleccionada
            if (currentApi === 'opentopodata') {
                return await calculateWithOpenTopoData(coordinates, enrichedData, cumulativeDistance);
            } else if (currentApi === 'google') {
                return await calculateWithGoogleMaps(coordinates, enrichedData, cumulativeDistance);
            } else {
                return await calculateWithManualElevation(coordinates, enrichedData, cumulativeDistance);
            }
        }

        async function calculateWithOpenTopoData(coordinates, enrichedData, cumulativeDistance) {
            const apiBaseUrl = 'https://api.opentopodata.org/v1/ned10m?locations=';
            const chunkSize = 100;
            const totalChunks = Math.ceil(coordinates.length / chunkSize);
            
            for (let i = 0; i < totalChunks; i++) {
                const chunk = coordinates.slice(i * chunkSize, (i + 1) * chunkSize);
                const locationsString = chunk.map(c => `${c.lat},${c.lon}`).join('|');
                
                updateStatus(`Obteniendo elevaciones: lote ${i+1} de ${totalChunks}...`, 'info');
                progressBar.style.width = `${(i / totalChunks) * 100}%`;
                
                try {
                    const response = await fetchWithTimeout(`${apiBaseUrl}${locationsString}`, {
                        timeout: 30000 // 30 segundos timeout
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Error de la API: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.status === 'OK') {
                        data.results.forEach((result, index) => {
                            const originalPoint = chunk[index];
                            let partialDistance = 0;
                            
                            if (enrichedData.length > 0) {
                                const prevPoint = enrichedData[enrichedData.length - 1];
                                partialDistance = haversine(prevPoint.lat, prevPoint.lon, originalPoint.lat, originalPoint.lon);
                                cumulativeDistance += partialDistance;
                            }
                            
                            enrichedData.push({
                                point: enrichedData.length + 1,
                                lat: originalPoint.lat,
                                lon: originalPoint.lon,
                                elevation: result.elevation,
                                partialDistance: partialDistance,
                                cumulativeDistance: cumulativeDistance
                            });
                        });
                    } else {
                        throw new Error(`Error de la API: ${data.status}`);
                    }
                } catch (error) {
                    console.error("Error en la llamada a la API:", error);
                    throw new Error(`Fallo al obtener elevaciones: ${error.message}`);
                }
                
                // Pequeña pausa entre solicitudes para no saturar la API
                await delay(500);
            }
            
            return enrichedData;
        }

        async function calculateWithGoogleMaps(coordinates, enrichedData, cumulativeDistance) {
            // Esta es una implementación básica que requeriría una clave API de Google
            // Por ahora, usaremos valores simulados ya que necesitarías una clave API válida
            
            updateStatus('Google Maps Elevation API requiere clave API. Usando valores de ejemplo.', 'warning');
            
            for (let i = 0; i < coordinates.length; i++) {
                const point = coordinates[i];
                let partialDistance = 0;
                
                if (enrichedData.length > 0) {
                    const prevPoint = enrichedData[enrichedData.length - 1];
                    partialDistance = haversine(prevPoint.lat, prevPoint.lon, point.lat, point.lon);
                    cumulativeDistance += partialDistance;
                }
                
                // Simular elevación (en una implementación real, aquí harías la llamada a Google Maps API)
                const simulatedElevation = point.elev !== null ? point.elev : Math.random() * 1000;
                
                enrichedData.push({
                    point: enrichedData.length + 1,
                    lat: point.lat,
                    lon: point.lon,
                    elevation: simulatedElevation,
                    partialDistance: partialDistance,
                    cumulativeDistance: cumulativeDistance
                });
                
                // Actualizar barra de progreso
                progressBar.style.width = `${(i / coordinates.length) * 100}%`;
                await delay(10); // Pequeña pausa para no bloquear la UI
            }
            
            return enrichedData;
        }

        async function calculateWithManualElevation(coordinates, enrichedData, cumulativeDistance) {
            updateStatus('Usando elevaciones existentes en el archivo KML o valor por defecto.', 'info');
            
            for (let i = 0; i < coordinates.length; i++) {
                const point = coordinates[i];
                let partialDistance = 0;
                
                if (enrichedData.length > 0) {
                    const prevPoint = enrichedData[enrichedData.length - 1];
                    partialDistance = haversine(prevPoint.lat, prevPoint.lon, point.lat, point.lon);
                    cumulativeDistance += partialDistance;
                }
                
                // Usar elevación existente o 0 por defecto
                const elevation = point.elev !== null ? point.elev : 0;
                
                enrichedData.push({
                    point: enrichedData.length + 1,
                    lat: point.lat,
                    lon: point.lon,
                    elevation: elevation,
                    partialDistance: partialDistance,
                    cumulativeDistance: cumulativeDistance
                });
                
                // Actualizar barra de progreso
                progressBar.style.width = `${(i / coordinates.length) * 100}%`;
                await delay(10); // Pequeña pausa para no bloquear la UI
            }
            
            return enrichedData;
        }

        // Función fetch con timeout
        async function fetchWithTimeout(resource, options = {}) {
            const { timeout = 10000 } = options;
            
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            
            const response = await fetch(resource, {
                ...options,
                signal: controller.signal  
            });
            clearTimeout(id);
            
            return response;
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Radio de la Tierra en metros
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        function createKml(kmlDoc, data) {
            // Clonar el documento para no modificar el original
            const newKmlDoc = kmlDoc.cloneNode(true);
            
            // Reconstruir la cadena de coordenadas con elevación
            const newCoordinates = data.map(point => 
                `${point.lon},${point.lat},${point.elevation}`
            ).join('\n');
            
            const coordinatesNode = newKmlDoc.querySelector('coordinates');
            if (coordinatesNode) {
                coordinatesNode.textContent = `\n${newCoordinates}\n`;
            }
            
            // Asegurar que existe el modo de altitud
            let altitudeMode = newKmlDoc.querySelector('altitudeMode');
            if (!altitudeMode) {
                altitudeMode = newKmlDoc.createElement('altitudeMode');
                altitudeMode.textContent = 'absolute';
                
                const lineString = newKmlDoc.querySelector('LineString');
                if (lineString) {
                    lineString.appendChild(altitudeMode);
                }
            }
            
            // Serializar a texto
            const serializer = new XMLSerializer();
            return serializer.serializeToString(newKmlDoc);
        }

        function createCsv(data) {
            const headers = "Punto,Latitud,Longitud,Elevación (m),Distancia Parcial (m),Distancia Acumulada (m)\n";
            const rows = data.map(point =>
                `${point.point},${point.lat.toFixed(6)},${point.lon.toFixed(6)},${point.elevation.toFixed(2)},${point.partialDistance.toFixed(2)},${point.cumulativeDistance.toFixed(2)}`
            ).join('\n');
            return headers + rows;
        }

        function updateStats(data) {
            if (data.length === 0) return;
            
            // Calcular estadísticas
            const totalPoints = data.length;
            const totalDistance = data[data.length - 1].cumulativeDistance;
            const elevations = data.map(point => point.elevation);
            const maxElevation = Math.max(...elevations);
            const minElevation = Math.min(...elevations);
            
            // Actualizar UI
            totalPointsEl.textContent = totalPoints;
            totalDistanceEl.textContent = totalDistance.toFixed(2);
            maxElevationEl.textContent = maxElevation.toFixed(2);
            minElevationEl.textContent = minElevation.toFixed(2);
            statsContainer.classList.remove('hidden');
        }

        function showDataPreview(data) {
            if (data.length === 0) return;
            
            // Limpiar tabla existente
            previewTableBody.innerHTML = '';
            
            // Determinar cuántos puntos mostrar (máximo 50)
            const maxPreviewPoints = 50;
            const step = Math.max(1, Math.floor(data.length / maxPreviewPoints));
            previewInfo.textContent = `Mostrando ${Math.min(maxPreviewPoints, data.length)} de ${data.length} puntos`;
            
            // Llenar la tabla con datos
            for (let i = 0; i < data.length; i += step) {
                if (previewTableBody.children.length >= maxPreviewPoints) break;
                
                const point = data[i];
                const row = document.createElement('tr');
                row.className = i % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                
                row.innerHTML = `
                    <td class="px-4 py-2 font-medium">${point.point}</td>
                    <td class="px-4 py-2">${point.lat.toFixed(6)}</td>
                    <td class="px-4 py-2">${point.lon.toFixed(6)}</td>
                    <td class="px-4 py-2 font-medium ${point.elevation > 0 ? 'text-green-600' : 'text-blue-600'}">${point.elevation.toFixed(2)}</td>
                    <td class="px-4 py-2">${point.partialDistance.toFixed(2)}</td>
                    <td class="px-4 py-2">${point.cumulativeDistance.toFixed(2)}</td>
                `;
                
                previewTableBody.appendChild(row);
            }
            
            // Mostrar el contenedor de vista previa
            previewContainer.classList.remove('hidden');
        }

        function updateStatus(message, type = 'info') {
            statusMessage.textContent = message;
            
            // Eliminar clases previas
            statusMessage.classList.remove('text-blue-500', 'text-red-500', 'text-green-600', 'text-yellow-600');
            
            // Aplicar clase según el tipo
            switch(type) {
                case 'error':
                    statusMessage.classList.add('text-red-500');
                    break;
                case 'success':
                    statusMessage.classList.add('text-green-600');
                    break;
                case 'warning':
                    statusMessage.classList.add('text-yellow-600');
                    break;
                default:
                    statusMessage.classList.add('text-blue-500');
            }
        }

        function downloadFile(content, fileName, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
